<!--
SYNC IMPACT REPORT
==================
Version change: 2.0.0 → 3.0.0
This is a MAJOR version update changing the backend architecture from serverless
(Vercel Functions) to a traditional long-lived Node.js server (Fastify) with
Docker-first deployment.

Modified principles:
  - III. Serverless Architecture Constraints → Fastify Server Architecture (complete redesign)
  - V. Dev/Prod Parity → updated for Docker-based deployment

Added sections:
  - Fastify Setup & Plugins (plugin architecture, decorated instances)
  - Docker & Container Architecture (dev and prod container setup)
  - Hosting Flexibility (VPS, PaaS, container platforms)

Removed sections:
  - Vercel-specific deployment patterns
  - Serverless function constraints (stateless, per-request connections)

Modified sections:
  - Technology Stack: Fastify replaces Vercel Functions
  - Project Structure: `server/` directory replaces `api/` directory
  - API Design Patterns: Fastify route handlers replace Vercel function handlers
  - Local Development Setup: Docker Compose for full stack
  - Runtime & Hosting: Docker containers + generic hosting (VPS/PaaS)

Templates requiring updates:
  ✅ .specify/templates/plan-template.md (Constitution Check updated for Fastify stack)
  ✅ .specify/templates/spec-template.md (Requirements align with new architecture)
  ✅ .specify/templates/tasks-template.md (Task types reflect traditional server patterns)

Follow-up TODOs:
  - Auth library selection deferred (JWT library + Fastify integration)
  - Hosting provider selection deferred (Hetzner, Railway, Render, Fly.io, etc.)
  - Production database provider deferred (Neon, Supabase, Railway Postgres, etc.)
  - Reverse proxy decision deferred (Fastify serves static files vs Nginx proxy)
  - Logging/monitoring solution deferred (console.log vs Pino vs external service)
-->

# Binge Ratings Constitution

**Project**: Binge Ratings
**Tagline**: "Our guide to smarter binge watching"
**Type**: Full-stack web application (React SPA + Fastify API Server)
**Owner**: Experienced full-stack developer (PHP/Laravel + React background)
**Purpose**: Personal training project focused on modern TypeScript, pragmatic architecture, and high development velocity

## Core Principles

### I. TypeScript-First Development (NON-NEGOTIABLE)

All code MUST be written in TypeScript with strict type checking enabled.

**Rules**:

- `strict: true` in all `tsconfig.json` files
- NO `any` types unless absolutely unavoidable and explicitly documented with a comment explaining why
- Use type inference where appropriate, but prefer explicit types for function signatures and public APIs
- Shared types MUST be defined in `lib/types/` and imported, never duplicated
- Database schema types are auto-generated by Drizzle and MUST NOT be manually written

**Rationale**: TypeScript is the first line of defense against bugs. Strong typing reduces the need for extensive unit testing and provides immediate feedback during development. Coming from PHP/Laravel, strict TypeScript discipline prevents runtime surprises.

### II. Simplicity & No Over-Engineering

Start with the simplest solution that works. Avoid premature abstraction.

**Rules**:

- NO microservices: single repo, single app, single Postgres database
- NO unnecessary frameworks: no Express, no NestJS, no Next.js
- NO architectural patterns beyond simple layering: no CQRS, no event sourcing, no hexagonal architecture
- NO speculative features: build what's needed now, not what might be needed later
- If adding complexity (new abstraction, new pattern, new library), document why simpler alternatives were insufficient

**DOs**:

- Use plain functions and simple data structures
- Keep components focused and single-purpose
- Prefer composition over inheritance
- Use standard library features before reaching for libraries

**DON'Ts**:

- Don't create abstraction layers until you have 3+ concrete use cases
- Don't add dependencies without evaluating the bundle size impact
- Don't create "framework" code or "engine" patterns

**Rationale**: Premature abstraction is the root of maintenance hell. Simple code is easier to understand, test, and change. Complexity should be earned through real requirements, not imagined future needs.

### III. Fastify Server Architecture

The backend MUST be implemented as a long-lived Fastify server running in a Docker container.

**Rules**:

- Single Fastify instance as the entrypoint for all server-side concerns
- NO serverless functions (this is a traditional Node.js server)
- NO Express, NO NestJS (Fastify only)
- Server runs as a persistent process, not ephemeral functions
- Database connection pooling managed at application startup
- In-memory caching is allowed (server is stateful)

**Plugin Architecture**:

- Use Fastify plugins to organize functionality:
  - Route registration (`showsRoutes`, `episodesRoutes`, `authRoutes`)
  - Database decoration (`fastify.db` for Drizzle instance)
  - Cross-cutting concerns (CORS, logging, error handling, auth)
- Each plugin is a separate file under `server/plugins/`

**Route Organization**:

```
server/
  routes/
    shows.ts       → /api/shows, /api/shows/:id
    episodes.ts    → /api/episodes/:id
    auth.ts        → /api/auth/login, /api/auth/register
    recommendations.ts → /api/recommendations
```

**Separation of Concerns**:

- Routes (Fastify handlers) handle HTTP request/response only
- Domain logic lives in `lib/domain/` (pure functions)
- Data access lives in `lib/db/` (Drizzle queries)

**CORS**:

- Development: Allow Vite dev server origin (`http://localhost:5173`)
- Production: Limit to deployed frontend origin or handle at reverse proxy

**Rationale**: Fastify provides modern, performant HTTP server capabilities with excellent TypeScript support. A traditional server model allows for connection pooling, in-memory caching, and stateful patterns when beneficial. Docker containerization ensures consistency across environments without vendor lock-in.

### IV. Pragmatic Testing Strategy

Testing is important, but MUST be pragmatic and focused to maintain development velocity.

**Test Scope**:

**MUST TEST** (high priority):

- Pure business logic functions: rating calculations, data transformations, filtering/sorting algorithms
- Non-trivial utilities used in multiple places: formatters, mappers, score normalization
- Any recommendation or ranking logic
- Complex database query builders (not simple CRUD)

**NICE TO HAVE** (when time allows):

- 1-2 key React components with `@testing-library/react` (focus on data fetching + state handling)
- 1-2 critical API endpoints tested with Fastify's `.inject()` method (no real HTTP)
- Chart components (verify correct data shape passed to library)

**OUT OF SCOPE** (for initial version):

- E2E tests with Playwright/Cypress (can be added later)
- Snapshot tests everywhere
- Tests for purely presentational components (static layout/styling only)
- 100% coverage as a goal

**Tools**:

- Test runner: `Vitest`
- React testing: `@testing-library/react` (minimal usage)
- Fastify testing: `fastify.inject()` for HTTP testing without real network
- NO E2E framework in initial phase

**Guidelines**:

- Prefer testing pure functions (no I/O, no network) over heavy mocking
- Keep tests next to code: `something.test.ts` alongside `something.ts`
- If TypeScript + simple code = low risk, skip unit tests
- Tests required only for logic that is: easy to break, hard to reason about, or business-critical

**Rationale**: This is a learning project prioritizing velocity. TypeScript provides strong safety. Tests should focus on complex logic where types alone can't prevent bugs. Comprehensive testing can be added incrementally as the project matures.

### V. Dev/Prod Parity

Local development MUST mirror production environment as closely as possible.

**Development Environment**:

- Frontend: Vite dev server (`npm run dev`)
- Backend: Fastify server running locally (`npm run server:dev`)
- Database: Local Postgres in Docker (via `docker-compose`)
- Environment variables: `.env` file (never committed)

**Production Environment**:

- Frontend: Static assets built by Vite, served by Fastify or Nginx
- Backend: Fastify server running in Docker container
- Database: Managed Postgres (Neon, Supabase, Railway, or similar)
- Environment variables: Platform-provided or Docker secrets

**Configuration Parity**:

- Same Node.js version in dev and prod (defined in `Dockerfile` and `.nvmrc`)
- Same Postgres version in dev and prod
- Same environment variable names in `.env` and production config
- Database connection string format identical (with different credentials)

**Container Parity**:

- Use Docker Compose in development for full-stack local environment
- Use same Dockerfile for local testing and production deployment
- Verify app works in container locally before deploying

**Rationale**: "Works on my machine" bugs waste time. Dev/prod parity catches deployment issues early. Docker ensures the exact same runtime environment everywhere. This approach avoids cloud vendor lock-in and enables deployment flexibility.

## Technology Stack

### Locked-In Choices (NON-NEGOTIABLE)

**Frontend**:

- React 18+ (function components + hooks only, no class components)
- TypeScript (strict mode)
- Vite (build tool + dev server)
- Tailwind CSS v4 (installed as Vite plugin)
- NO Next.js, NO Remix, NO server-side rendering

**Backend/API**:

- Fastify (TypeScript)
- Node.js LTS (long-lived server process)
- NO Express, NO NestJS
- NO serverless platforms (Vercel Functions, AWS Lambda, etc.)

**Database**:

- PostgreSQL (local Docker in dev, managed service in prod)
- Drizzle ORM (schema definition, migrations, query builder)
- Connection pooling at application startup

**Hosting & Deployment**:

- Docker-first: backend runs in container
- Platform-agnostic: deployable to VPS, PaaS, or container platforms
- Candidates: Hetzner, OVH, Railway, Render, Fly.io (final choice deferred)
- Single repository (monorepo pattern with shared code)

**Code Quality**:

- ESLint + Prettier OR Biome (choose one, configure once)
- TypeScript strict mode
- Vitest for testing

**Authentication** (high-level):

- Stateless JWT tokens stored in HTTP-only cookies
- JWT library integrated with Fastify (e.g., `@fastify/jwt`)
- NO session storage in database (stateless only)

## Architecture & Boundaries

### Three-Layer Architecture

```
┌─────────────────────────────────────────┐
│         Frontend (React SPA)            │
│  - UI components                        │
│  - State management (React hooks)       │
│  - API client (fetch)                   │
│  - Built by Vite → static assets        │
└─────────────────────────────────────────┘
              ↓ HTTP (JSON)
┌─────────────────────────────────────────┐
│    Backend (Fastify Server)             │
│  - HTTP routes (/api/...)               │
│  - Request validation (schemas)         │
│  - Auth middleware                      │
│  - Calls domain logic                   │
│  - CORS handling                        │
│  - Error handling                       │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│      Domain + Data Layer (/lib)         │
│  - Business logic (pure functions)      │
│  - Data access (Drizzle queries)        │
│  - Database schema (Drizzle schema)     │
│  - Shared types                         │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│          PostgreSQL Database            │
│  (Docker container in dev,              │
│   managed service in prod)              │
└─────────────────────────────────────────┘
```

### Separation of Concerns

**Transport Layer** (`server/routes/`):

- Receive HTTP request, parse body/query/params
- Validate input (Fastify schemas or Zod)
- Call domain logic
- Format response (JSON)
- Handle HTTP-specific concerns (status codes, headers, cookies)
- MUST NOT contain business logic

**Domain Layer** (`lib/domain/`):

- Pure business logic
- Testable functions that don't know about HTTP
- Data transformations, calculations, filtering, sorting
- Orchestrate data access calls
- Return plain data structures

**Data Layer** (`lib/db/`):

- Drizzle schema definitions (`schema.ts`)
- Database connection setup (`client.ts`)
- Query helpers (if needed for complex queries)
- Migrations (managed by Drizzle)
- MUST NOT contain business logic

## Project Structure & Conventions

### Directory Layout

```
binge-ratings/
├── src/                        # Frontend (React + Vite)
│   ├── components/             # React components
│   │   ├── shows/              # Feature-based grouping
│   │   ├── episodes/
│   │   ├── charts/
│   │   └── common/             # Shared UI components
│   ├── pages/                  # Page-level components (routes)
│   ├── hooks/                  # Custom React hooks
│   ├── lib/                    # Frontend-only utilities
│   ├── styles/                 # Global styles, Tailwind config
│   ├── App.tsx
│   ├── main.tsx
│   └── vite-env.d.ts
│
├── server/                     # Backend (Fastify server)
│   ├── index.ts                # Server entrypoint
│   ├── app.ts                  # Fastify app setup
│   ├── routes/                 # Route handlers
│   │   ├── shows.ts            # GET/POST /api/shows
│   │   ├── episodes.ts         # GET /api/episodes
│   │   ├── auth.ts             # POST /api/auth/login, etc.
│   │   └── recommendations.ts  # GET /api/recommendations
│   ├── plugins/                # Fastify plugins
│   │   ├── db.ts               # Database decorator
│   │   ├── auth.ts             # JWT/auth plugin
│   │   ├── cors.ts             # CORS configuration
│   │   └── error-handler.ts   # Centralized error handling
│   └── middleware/             # Custom middleware (if needed)
│
├── lib/                        # Shared code (frontend + backend)
│   ├── db/                     # Database layer
│   │   ├── schema.ts           # Drizzle schema definitions
│   │   ├── client.ts           # Database connection
│   │   └── migrations/         # SQL migrations (Drizzle Kit)
│   ├── domain/                 # Business logic (pure functions)
│   │   ├── shows.ts            # Show-related logic
│   │   ├── episodes.ts         # Episode-related logic
│   │   └── ratings.ts          # Rating calculations
│   ├── types/                  # Shared TypeScript types
│   │   ├── api.ts              # API request/response types
│   │   └── domain.ts           # Domain entity types
│   └── utils/                  # Shared utilities
│       ├── validation.ts       # Input validation helpers
│       └── format.ts           # Formatters, mappers
│
├── tests/                      # Tests (if not colocated)
│   ├── domain/                 # Domain logic tests
│   └── integration/            # API integration tests (Fastify .inject())
│
├── docker/                     # Docker configuration
│   ├── Dockerfile              # Production Dockerfile
│   ├── Dockerfile.dev          # Development Dockerfile (optional)
│   └── docker-compose.yml      # Local dev environment
│
├── .env.example                # Example environment variables
├── .env                        # Local environment variables (git-ignored)
├── .nvmrc                      # Node.js version
├── drizzle.config.ts           # Drizzle ORM configuration
├── tsconfig.json               # Root TypeScript config
├── tsconfig.node.json          # Node/Server TypeScript config
├── vite.config.ts              # Vite configuration
├── vitest.config.ts            # Vitest configuration
└── package.json
```

### Naming Conventions

**Files**:

- React components: `PascalCase.tsx` (e.g., `ShowCard.tsx`)
- Utilities, helpers: `camelCase.ts` (e.g., `formatDate.ts`)
- Fastify routes: `camelCase.ts` (e.g., `shows.ts`, `auth.ts`)
- Tests: `*.test.ts` or `*.test.tsx` (colocated with code)

**Imports**:

- Use path aliases configured in `tsconfig.json`:
  - `@/components/...` → `src/components/...`
  - `@/lib/...` → `lib/...`
  - `@/server/...` → `server/...`

**Components**:

- Function components only, no class components
- Export component as default: `export default function ShowCard() { ... }`
- Props interface named `[ComponentName]Props`: `interface ShowCardProps { ... }`

**API Responses**:

- Always return JSON with consistent structure:

  ```ts
  // Success
  { data: T, error: null }

  // Error
  { data: null, error: { message: string, code?: string } }
  ```

## API Design Patterns

### RESTful Conventions

- `GET /api/shows` → List shows
- `GET /api/shows/:id` → Get show by ID
- `GET /api/shows/:id/episodes` → Get episodes for a show
- `GET /api/episodes/:id` → Get episode by ID
- `POST /api/shows` → Create show (if needed)
- `PUT /api/shows/:id` → Update show (if needed)
- `DELETE /api/shows/:id` → Delete show (if needed)

Use standard HTTP status codes:

- `200 OK` → Success
- `201 Created` → Resource created
- `400 Bad Request` → Validation error
- `401 Unauthorized` → Auth required
- `403 Forbidden` → Insufficient permissions
- `404 Not Found` → Resource not found
- `422 Unprocessable Entity` → Business logic error
- `500 Internal Server Error` → Unhandled error

### Fastify Route Handler Pattern

Every route is defined as a Fastify plugin:

```ts
// server/routes/shows.ts
import { FastifyPluginAsync } from 'fastify';
import { getShowById } from '@/lib/domain/shows';

const showsRoutes: FastifyPluginAsync = async (fastify) => {
  // GET /api/shows/:id
  fastify.get<{
    Params: { id: string };
  }>('/api/shows/:id', async (request, reply) => {
    const { id } = request.params;

    // Validate
    if (!id || isNaN(Number(id))) {
      return reply.status(400).send({
        data: null,
        error: { message: 'Invalid show ID' },
      });
    }

    // Call domain logic
    try {
      const show = await getShowById(fastify.db, Number(id));

      if (!show) {
        return reply.status(404).send({
          data: null,
          error: { message: 'Show not found' },
        });
      }

      return reply.send({ data: show, error: null });
    } catch (error) {
      fastify.log.error(error, 'Error fetching show');
      return reply.status(500).send({
        data: null,
        error: { message: 'Internal server error' },
      });
    }
  });
};

export default showsRoutes;
```

### Request/Response Validation

Use Fastify JSON Schema or Zod for validation:

```ts
// With Fastify schema
fastify.post(
  '/api/shows',
  {
    schema: {
      body: {
        type: 'object',
        required: ['title'],
        properties: {
          title: { type: 'string', minLength: 1 },
          description: { type: 'string' },
        },
      },
    },
  },
  async (request, reply) => {
    // Body is validated automatically
    const { title, description } = request.body;
    // ...
  }
);
```

### Error Handling

**Centralized Error Handler** (`server/plugins/error-handler.ts`):

```ts
import { FastifyPluginAsync } from 'fastify';

const errorHandler: FastifyPluginAsync = async (fastify) => {
  fastify.setErrorHandler((error, request, reply) => {
    // Log with context
    fastify.log.error(
      {
        error,
        url: request.url,
        method: request.method,
      },
      'Request error'
    );

    // Don't expose internal errors to client
    if (error.statusCode && error.statusCode < 500) {
      return reply.status(error.statusCode).send({
        data: null,
        error: { message: error.message },
      });
    }

    // Generic 500 error
    return reply.status(500).send({
      data: null,
      error: { message: 'Internal server error' },
    });
  });
};

export default errorHandler;
```

**Business Errors**:

- Define custom error classes for business logic errors
- Map them to appropriate HTTP status codes in error handler

## Fastify Setup & Plugins

### Application Setup

**Server Entrypoint** (`server/index.ts`):

```ts
import { createApp } from './app';

const start = async () => {
  const app = await createApp({
    logger: {
      level: process.env.LOG_LEVEL || 'info',
    },
  });

  const port = Number(process.env.PORT) || 4000;
  const host = process.env.HOST || '0.0.0.0';

  try {
    await app.listen({ port, host });
    console.log(`Server listening on http://${host}:${port}`);
  } catch (err) {
    app.log.error(err);
    process.exit(1);
  }
};

start();
```

**App Factory** (`server/app.ts`):

```ts
import Fastify, { FastifyServerOptions } from 'fastify';
import dbPlugin from './plugins/db';
import authPlugin from './plugins/auth';
import corsPlugin from './plugins/cors';
import errorHandler from './plugins/error-handler';
import showsRoutes from './routes/shows';
import episodesRoutes from './routes/episodes';
import authRoutes from './routes/auth';

export async function createApp(opts: FastifyServerOptions = {}) {
  const app = Fastify(opts);

  // Register plugins
  await app.register(dbPlugin);
  await app.register(authPlugin);
  await app.register(corsPlugin);
  await app.register(errorHandler);

  // Register routes
  await app.register(showsRoutes);
  await app.register(episodesRoutes);
  await app.register(authRoutes);

  // Health check
  app.get('/health', async () => {
    return { status: 'ok' };
  });

  return app;
}
```

### Database Plugin

**Database Decorator** (`server/plugins/db.ts`):

```ts
import { FastifyPluginAsync } from 'fastify';
import fp from 'fastify-plugin';
import { db } from '@/lib/db/client';

declare module 'fastify' {
  interface FastifyInstance {
    db: typeof db;
  }
}

const dbPlugin: FastifyPluginAsync = async (fastify) => {
  fastify.decorate('db', db);

  fastify.addHook('onClose', async () => {
    // Close database connections on shutdown
    await db.$client.end();
  });
};

export default fp(dbPlugin);
```

### Plugin Organization

All plugins go in `server/plugins/`:

- `db.ts` - Database decorator
- `auth.ts` - JWT/authentication
- `cors.ts` - CORS configuration
- `error-handler.ts` - Centralized error handling
- Add more as needed (rate limiting, caching, etc.)

## Data Layer Patterns

### Drizzle ORM Usage

**Schema Definition** (`lib/db/schema.ts`):

```ts
import { pgTable, serial, text, timestamp, integer } from 'drizzle-orm/pg-core';

export const shows = pgTable('shows', {
  id: serial('id').primaryKey(),
  title: text('title').notNull(),
  description: text('description'),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
});

export const episodes = pgTable('episodes', {
  id: serial('id').primaryKey(),
  showId: integer('show_id')
    .references(() => shows.id)
    .notNull(),
  seasonNumber: integer('season_number').notNull(),
  episodeNumber: integer('episode_number').notNull(),
  title: text('title').notNull(),
  rating: integer('rating'), // 0-100 or similar
  createdAt: timestamp('created_at').defaultNow().notNull(),
});
```

**Database Client** (`lib/db/client.ts`):

```ts
import { drizzle } from 'drizzle-orm/node-postgres';
import { Pool } from 'pg';
import * as schema from './schema';

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  max: 20, // Connection pool size
});

export const db = drizzle(pool, { schema });
```

**Query Patterns**:

```ts
// Simple query
const allShows = await db.select().from(shows);

// With where clause
const show = await db.select().from(shows).where(eq(shows.id, id)).limit(1);

// Join
const showWithEpisodes = await db
  .select()
  .from(shows)
  .leftJoin(episodes, eq(episodes.showId, shows.id))
  .where(eq(shows.id, id));
```

**Migrations**:

- Use Drizzle Kit: `drizzle-kit generate:pg` to create migrations
- Apply with: `drizzle-kit push:pg` or `drizzle-kit migrate`
- Store migrations in `lib/db/migrations/`

**Conventions**:

- All database queries go through Drizzle (no raw SQL unless absolutely necessary)
- Pass `db` instance as parameter to domain functions (dependency injection)
- Export types from schema: `export type Show = typeof shows.$inferSelect;`

## Authentication Strategy

### High-Level Design

**Auth Storage**:

- JWT token stored in HTTP-only cookie (not accessible via JavaScript)
- Token contains user ID, email, expiration
- Token signed with secret key (stored in environment variable)

**Protected Routes**:

- Fastify decorators or hooks check for valid JWT in cookie
- If missing/invalid → return `401 Unauthorized`
- If valid → attach user info to `request.user`

**Auth Endpoints**:

- `POST /api/auth/register` → Create user, return JWT in cookie
- `POST /api/auth/login` → Validate credentials, return JWT in cookie
- `POST /api/auth/logout` → Clear cookie
- `GET /api/auth/me` → Return current user info (if authenticated)

**Password Storage**:

- Hash passwords with bcrypt (or argon2)
- NEVER store plain-text passwords
- Salt per-password (handled by bcrypt automatically)

**Fastify Integration**:

- Use `@fastify/jwt` for JWT signing/verification
- Use `@fastify/cookie` for cookie handling
- Create auth decorator or hook for protecting routes

**Implementation Details** (deferred):

- Exact JWT library configuration
- Token expiration strategy (refresh tokens?)
- Final decision in implementation phase

## Error Handling & Logging

### Error Handling

**In Route Handlers**:

- Wrap logic in try-catch
- Differentiate between expected errors (validation, not found) and unexpected errors
- Use Fastify's error handling mechanisms

**In Domain Layer**:

- Throw custom error classes for business errors
- Let errors bubble up to route handlers
- Route handlers map errors to HTTP responses

**Centralized**:

- Single error handler plugin logs and formats all errors
- Never expose internal error details to client (no stack traces in production)
- Return user-friendly error messages

### Logging

**Built-in Fastify Logger**:

- Fastify includes Pino logger by default
- Configure log level via environment variable
- Structured JSON logging in production

**What to Log**:

- All unhandled errors (with stack trace)
- Auth events (login, logout, failed attempts)
- Slow queries (if performance monitoring added)
- Request metadata (method, path, duration)

**Logging Provider** (deferred):

- Use built-in Pino logger initially
- Can integrate external service later (e.g., Sentry, LogRocket, Grafana)

**DO NOT log**:

- Passwords or tokens
- Full request bodies if they contain sensitive data
- User PII unless necessary for debugging (and then redact in prod)

## Docker & Container Architecture

### Development with Docker Compose

**docker-compose.yml**:

```yaml
version: '3.8'

services:
  postgres:
    image: postgres:15
    container_name: binge-ratings-db
    environment:
      POSTGRES_USER: binge_user
      POSTGRES_PASSWORD: binge_pass
      POSTGRES_DB: binge_ratings
    ports:
      - '5432:5432'
    volumes:
      - postgres_data:/var/lib/postgresql/data

  server:
    build:
      context: .
      dockerfile: docker/Dockerfile.dev
    container_name: binge-ratings-server
    environment:
      DATABASE_URL: postgresql://binge_user:binge_pass@postgres:5432/binge_ratings
      PORT: 4000
      NODE_ENV: development
    ports:
      - '4000:4000'
    volumes:
      - .:/app
      - /app/node_modules
    depends_on:
      - postgres
    command: npm run server:dev

volumes:
  postgres_data:
```

### Production Dockerfile

**docker/Dockerfile**:

```dockerfile
FROM node:18-alpine AS builder

WORKDIR /app

# Install dependencies
COPY package*.json ./
RUN npm ci --only=production

# Copy source
COPY . .

# Build frontend
RUN npm run build

FROM node:18-alpine

WORKDIR /app

# Copy built assets and dependencies
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/server ./server
COPY --from=builder /app/lib ./lib
COPY --from=builder /app/package.json ./

EXPOSE 4000

CMD ["node", "server/index.js"]
```

### Environment Variables

**Required Variables**:

- `DATABASE_URL` - PostgreSQL connection string
- `PORT` - Server port (default 4000)
- `NODE_ENV` - `development` or `production`
- `JWT_SECRET` - Secret key for JWT signing

**Optional Variables**:

- `LOG_LEVEL` - Log verbosity (`debug`, `info`, `warn`, `error`)
- `CORS_ORIGIN` - Allowed CORS origin (frontend URL)
- `HOST` - Bind address (default `0.0.0.0`)

## Hosting & Deployment

### Deployment Flexibility

The architecture is provider-agnostic and supports:

**VPS Hosting** (e.g., Hetzner, OVH, DigitalOcean):

- SSH into server
- Install Docker
- Run `docker-compose up -d` or deploy single container
- Use Nginx as reverse proxy (optional)

**Container PaaS** (e.g., Railway, Render, Fly.io):

- Connect repository
- Platform builds and deploys Docker container automatically
- Configure environment variables via platform UI
- Platform handles SSL, domains, scaling

**Manual Deployment**:

1. Build Docker image: `docker build -f docker/Dockerfile -t binge-ratings .`
2. Push to registry (Docker Hub, GHCR, or private)
3. Pull and run on server: `docker run -p 4000:4000 --env-file .env binge-ratings`

### Static Asset Serving

**Option 1: Fastify serves static files**:

- Use `@fastify/static` plugin
- Serve `dist/` directory at root
- API routes under `/api/*`

**Option 2: Nginx reverse proxy**:

- Nginx serves `dist/` directly (faster for static files)
- Nginx forwards `/api/*` to Fastify backend
- More complex but better performance

**Decision**: Start with Option 1 (Fastify serves all), migrate to Option 2 if needed.

### Database in Production

**Managed Postgres Options**:

- Neon (serverless Postgres, generous free tier)
- Supabase (Postgres + additional features)
- Railway Postgres (simple, integrated with Railway hosting)
- Any standard Postgres provider (AWS RDS, DigitalOcean, etc.)

**Connection**:

- App only needs `DATABASE_URL` environment variable
- Use connection pooling (configured in `lib/db/client.ts`)
- Consider connection limits based on provider tier

### SSL/TLS

**Development**: HTTP only (no SSL needed)

**Production**:

- Use platform-provided SSL (Railway, Render, Fly.io handle automatically)
- OR use Let's Encrypt + Nginx if self-hosting on VPS
- NEVER handle SSL termination in Node.js application

## Local Development Setup

### Prerequisites

- Node.js 18+ (check `.nvmrc` for exact version)
- Docker & Docker Compose
- Git

### First-Time Setup

1. Clone repository:

   ```bash
   git clone <repo-url>
   cd binge-ratings
   ```

2. Install dependencies:

   ```bash
   npm install
   ```

3. Copy environment variables:

   ```bash
   cp .env.example .env
   ```

4. Start Docker Compose (Postgres + server):

   ```bash
   docker-compose up -d postgres
   ```

5. Run database migrations:

   ```bash
   npm run db:migrate
   ```

6. Start development servers:

   ```bash
   # Terminal 1: Vite frontend dev server
   npm run dev

   # Terminal 2: Fastify backend dev server
   npm run server:dev
   ```

7. Access application:
   - Frontend: `http://localhost:5173`
   - Backend API: `http://localhost:4000/api`
   - Health check: `http://localhost:4000/health`

### Development Workflow

**Frontend Development**:

- `npm run dev` → Vite dev server with HMR
- Edit files in `src/`
- Hot module replacement for instant feedback

**Backend Development**:

- `npm run server:dev` → Fastify server with auto-reload
- Edit files in `server/` or `lib/`
- Server restarts automatically on file changes

**Database Changes**:

1. Edit `lib/db/schema.ts`
2. Generate migration: `npm run db:generate`
3. Apply migration: `npm run db:migrate`
4. Migration files stored in `lib/db/migrations/`

**Testing**:

- Run tests: `npm test`
- Watch mode: `npm run test:watch`
- Coverage: `npm run test:coverage` (optional)

**Linting & Formatting**:

- Lint: `npm run lint`
- Format: `npm run format`
- Type check: `npm run typecheck`

### Package.json Scripts

```json
{
  "scripts": {
    "dev": "vite",
    "server:dev": "tsx watch server/index.ts",
    "build": "vite build && tsc -p tsconfig.node.json",
    "test": "vitest",
    "test:watch": "vitest --watch",
    "db:generate": "drizzle-kit generate:pg",
    "db:migrate": "drizzle-kit push:pg",
    "lint": "eslint . --ext .ts,.tsx",
    "format": "prettier --write .",
    "typecheck": "tsc --noEmit"
  }
}
```

## Development Workflow

### Feature Development Process

1. **Plan**: Define feature requirements and acceptance criteria
2. **Design**: Sketch data model, API contracts, UI layout
3. **Implement**: Write code (TypeScript-first, test critical logic)
4. **Test**: Run unit tests, manually test in browser
5. **Review**: Self-review for principle compliance before commit
6. **Deploy**: Push to `main` → CI builds Docker image → deploy to platform

### Branching Strategy

- `main` branch is always deployable
- Feature branches: `feature/short-description` (e.g., `feature/show-ratings`)
- Commit directly to `main` for small changes (learning project, no team)
- Use branches for larger features or experiments

### Commit Standards

- Use conventional commits format: `type: description`
  - `feat:` new feature
  - `fix:` bug fix
  - `refactor:` code refactor (no behavior change)
  - `test:` add/update tests
  - `docs:` documentation
  - `chore:` tooling, config changes
- Keep commits focused and atomic
- Write clear commit messages (why, not just what)

## Governance

### Amendment Process

Constitution amendments require:

1. Written proposal with rationale
2. Impact analysis: what code/config needs to change?
3. Version bump following semantic versioning:
   - **MAJOR**: Backward-incompatible changes (e.g., switching from Fastify to Express)
   - **MINOR**: New principles or technology choices (e.g., adding E2E testing)
   - **PATCH**: Clarifications, wording improvements, fixing typos
4. Update this file with new version and sync impact report
5. Update dependent templates and documentation

### Compliance

Before starting a feature:

- Review relevant constitution sections
- Ensure tech stack compliance (Fastify, no serverless, Docker-first)
- Verify architecture patterns followed

During code review (self-review):

- Check for `any` types (should be rare and documented)
- Verify separation of concerns (routes vs domain vs data)
- Ensure tests exist for complex logic
- Confirm no prohibited technologies introduced (no Express, no serverless)

Use `/speckit.analyze` command for automated cross-artifact consistency checks.

### Versioning Policy

This constitution follows semantic versioning (MAJOR.MINOR.PATCH).
Changes are tracked in the Sync Impact Report at the top of this file.

### Open Questions (Deferred to Implementation Phase)

- **Auth Library**: Use `@fastify/jwt` + `@fastify/cookie` or higher-level auth solution?
- **Hosting Provider**: Hetzner VPS, Railway, Render, Fly.io, or other?
- **Database Provider**: Neon, Supabase, Railway Postgres, or self-hosted?
- **Reverse Proxy**: Fastify serves static files or add Nginx layer?
- **Logging Provider**: Built-in Pino or integrate Sentry/LogRocket?
- **State Management**: Built-in React hooks or add Zustand/Jotai?
- **Form Handling**: Plain controlled components or use React Hook Form?
- **API Client**: Plain `fetch` or wrap in helper (e.g., `ky`)?

**Version**: 3.0.0 | **Ratified**: 2025-12-01 | **Last Amended**: 2025-12-01
