<!--
SYNC IMPACT REPORT
==================
Version change: 1.0.0 → 2.0.0
This is a MAJOR version update replacing the generic constitution with project-specific
rules for the Binge Ratings project.

Modified principles:
  - I. Test-Driven Development → TypeScript-First Development (redefined scope)
  - II. Simplicity First → Simplicity & No Over-Engineering (retained, clarified)
  - III. Clear Contracts and Interfaces → Serverless Architecture Constraints (new focus)
  - IV. Incremental Delivery → Pragmatic Testing Strategy (new principle)
  - V. Observability and Debuggability → Dev/Prod Parity (new principle)

Added sections:
  - Technology Stack (locked-in choices)
  - Architecture & Boundaries (frontend/backend/database specifics)
  - Project Structure & Conventions (directory layout)
  - API Design Patterns (Vercel Functions specific)
  - Data Layer Patterns (Drizzle ORM specific)
  - Authentication Strategy (JWT/cookie-based)
  - Error Handling & Logging
  - Local Development Setup

Removed sections:
  - Generic Quality Standards (replaced with Technology Stack section)
  - Generic Development Workflow (replaced with project-specific patterns)

Templates requiring updates:
  ✅ .specify/templates/plan-template.md (Constitution Check will verify stack compliance)
  ✅ .specify/templates/spec-template.md (Requirements align with tech constraints)
  ✅ .specify/templates/tasks-template.md (Task types reflect new principles)

Follow-up TODOs:
  - Auth library selection deferred to implementation phase (JWT vs auth helper library)
  - Observability tooling deferred (logging/monitoring provider selection)
  - Production database provider deferred (Neon vs Supabase vs other)
-->

# Binge Ratings Constitution

**Project**: Binge Ratings
**Tagline**: "Our guide to smarter binge watching"
**Type**: Full-stack web application (SPA + Serverless API)
**Owner**: Experienced full-stack developer (PHP/Laravel + React background)
**Purpose**: Personal training project focused on modern TypeScript, pragmatic architecture, and high development velocity

## Core Principles

### I. TypeScript-First Development (NON-NEGOTIABLE)

All code MUST be written in TypeScript with strict type checking enabled.

**Rules**:
- `strict: true` in all `tsconfig.json` files
- NO `any` types unless absolutely unavoidable and explicitly documented with a comment explaining why
- Use type inference where appropriate, but prefer explicit types for function signatures and public APIs
- Shared types MUST be defined in `lib/types/` and imported, never duplicated
- Database schema types are auto-generated by Drizzle and MUST NOT be manually written

**Rationale**: TypeScript is the first line of defense against bugs. Strong typing reduces the need for extensive unit testing and provides immediate feedback during development. Coming from PHP/Laravel, strict TypeScript discipline prevents runtime surprises.

### II. Simplicity & No Over-Engineering

Start with the simplest solution that works. Avoid premature abstraction.

**Rules**:
- NO microservices: single repo, single app, single Postgres database
- NO unnecessary frameworks: no Express, no NestJS, no Next.js API routes
- NO architectural patterns beyond simple layering: no CQRS, no event sourcing, no hexagonal architecture
- NO speculative features: build what's needed now, not what might be needed later
- If adding complexity (new abstraction, new pattern, new library), document why simpler alternatives were insufficient

**DOs**:
- Use plain functions and simple data structures
- Keep components focused and single-purpose
- Prefer composition over inheritance
- Use standard library features before reaching for libraries

**DON'Ts**:
- Don't create abstraction layers until you have 3+ concrete use cases
- Don't add dependencies without evaluating the bundle size impact
- Don't create "framework" code or "engine" patterns

**Rationale**: Premature abstraction is the root of maintenance hell. Simple code is easier to understand, test, and change. Complexity should be earned through real requirements, not imagined future needs.

### III. Serverless Architecture Constraints

The backend MUST be implemented as stateless Vercel Serverless Functions.

**Rules**:
- Each API endpoint is a separate file in `/api` directory
- NO long-lived Node servers (no Express app listening on a port)
- Each function MUST be stateless: no in-memory caches, no global state between invocations
- Database connections MUST be established per-request (using connection pooling via Drizzle)
- File uploads MUST NOT use local filesystem (use external storage if needed)
- Sessions MUST be stateless (JWT) or cookie-based, never in-memory

**API File Structure**:
```
api/
  shows/
    index.ts          → GET /api/shows (list)
    [id].ts           → GET /api/shows/:id (detail)
  episodes/
    [id].ts           → GET /api/episodes/:id
  auth/
    login.ts          → POST /api/auth/login
    register.ts       → POST /api/auth/register
```

**Rationale**: Vercel Functions are ephemeral and stateless by design. Any code assuming persistent process state will break in production. Embracing these constraints leads to simpler, more scalable architectures.

### IV. Pragmatic Testing Strategy

Testing is important, but MUST be pragmatic and focused to maintain development velocity.

**Test Scope**:

**MUST TEST** (high priority):
- Pure business logic functions: rating calculations, data transformations, filtering/sorting algorithms
- Non-trivial utilities used in multiple places: formatters, mappers, score normalization
- Any recommendation or ranking logic
- Database query builders that have complex logic (not simple CRUD)

**NICE TO HAVE** (when time allows):
- 1-2 key React components with `@testing-library/react` (focus on data fetching + state handling)
- 1-2 critical API endpoints tested as plain functions (mock request → verify response)
- Chart components (verify correct data shape passed to library)

**OUT OF SCOPE** (for initial version):
- E2E tests with Playwright/Cypress (can be added later)
- Snapshot tests everywhere
- Tests for purely presentational components (static layout/styling only)
- 100% coverage as a goal

**Tools**:
- Test runner: `Vitest`
- React testing: `@testing-library/react` (minimal usage)
- NO E2E framework in initial phase

**Guidelines**:
- Prefer testing pure functions (no I/O, no network) over heavy mocking
- Keep tests next to code: `something.test.ts` alongside `something.ts`
- If TypeScript + simple code = low risk, skip unit tests
- Tests required only for logic that is: easy to break, hard to reason about, or business-critical

**Rationale**: This is a learning project prioritizing velocity. TypeScript provides strong safety. Tests should focus on complex logic where types alone can't prevent bugs. Comprehensive testing can be added incrementally as the project matures.

### V. Dev/Prod Parity

Local development MUST mirror production environment as closely as possible.

**Development Environment**:
- Frontend: Vite dev server (`npm run dev`)
- Backend: `vercel dev` (simulates Vercel Functions locally)
- Database: Local Postgres in Docker OR managed Postgres (same provider as prod)
- Environment variables: `.env` file (never committed)

**Production Environment**:
- Frontend: Static assets built by Vite, served by Vercel CDN
- Backend: Vercel Serverless Functions (Node.js runtime, not Edge)
- Database: Managed Postgres (Neon, Supabase, or similar)
- Environment variables: Vercel Environment Variables

**Configuration Parity**:
- Same Node.js version in dev and prod (defined in `package.json` engines field)
- Same Postgres version in dev and prod
- Same environment variable names in `.env` and Vercel dashboard
- Database connection string format identical (with different credentials)

**Rationale**: "Works on my machine" bugs waste time. Dev/prod parity catches deployment issues early and makes debugging production problems locally feasible.

## Technology Stack

### Locked-In Choices (NON-NEGOTIABLE)

**Frontend**:
- React 18+ (function components + hooks only, no class components)
- TypeScript (strict mode)
- Vite (build tool + dev server)
- Tailwind CSS v4 (installed as Vite plugin)
- NO Next.js, NO Remix, NO server-side rendering

**Backend/API**:
- Vercel Serverless Functions (Node.js runtime)
- TypeScript
- NO Express, NO Fastify, NO NestJS
- NO Next.js API routes

**Database**:
- PostgreSQL (local Docker in dev, managed service in prod)
- Drizzle ORM (schema definition, migrations, query builder)
- Connection pooling via Drizzle's built-in support

**Hosting & Deployment**:
- Vercel (frontend + backend)
- Single repository (monorepo pattern with shared code)

**Code Quality**:
- ESLint + Prettier OR Biome (choose one, configure once)
- TypeScript strict mode
- Vitest for testing

**Authentication** (high-level):
- Stateless JWT tokens stored in HTTP-only cookies
- OR auth library compatible with Vercel Functions (final choice deferred)
- NO session storage in database (stateless only)

## Architecture & Boundaries

### Three-Layer Architecture

```
┌─────────────────────────────────────────┐
│         Frontend (React SPA)            │
│  - UI components                        │
│  - State management (React hooks)       │
│  - API client (fetch)                   │
│  - Built by Vite → static assets        │
└─────────────────────────────────────────┘
              ↓ HTTP (JSON)
┌─────────────────────────────────────────┐
│    Backend (Vercel Functions)           │
│  - HTTP handlers (/api directory)       │
│  - Request validation                   │
│  - Auth middleware                      │
│  - Calls domain logic                   │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│      Domain + Data Layer (/lib)         │
│  - Business logic (pure functions)      │
│  - Data access (Drizzle queries)        │
│  - Database schema (Drizzle schema)     │
│  - Shared types                         │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│          PostgreSQL Database            │
└─────────────────────────────────────────┘
```

### Separation of Concerns

**Transport Layer** (`/api`):
- Receive HTTP request, parse body/query/params
- Validate input (schema validation)
- Call domain logic
- Format response (JSON)
- Handle HTTP-specific concerns (status codes, headers, cookies)
- MUST NOT contain business logic

**Domain Layer** (`/lib/domain` or `/lib/services`):
- Pure business logic
- Testable functions that don't know about HTTP
- Data transformations, calculations, filtering, sorting
- Orchestrate data access calls
- Return plain data structures

**Data Layer** (`/lib/db`):
- Drizzle schema definitions (`schema.ts`)
- Database connection setup (`client.ts`)
- Query helpers (if needed for complex queries)
- Migrations (managed by Drizzle)
- MUST NOT contain business logic

## Project Structure & Conventions

### Directory Layout

```
binge-ratings/
├── src/                        # Frontend (React + Vite)
│   ├── components/             # React components
│   │   ├── shows/              # Feature-based grouping
│   │   ├── episodes/
│   │   ├── charts/
│   │   └── common/             # Shared UI components
│   ├── pages/                  # Page-level components (routes)
│   ├── hooks/                  # Custom React hooks
│   ├── lib/                    # Frontend-only utilities
│   ├── styles/                 # Global styles, Tailwind config
│   ├── App.tsx
│   ├── main.tsx
│   └── vite-env.d.ts
│
├── api/                        # Backend (Vercel Functions)
│   ├── shows/
│   │   ├── index.ts            # GET /api/shows
│   │   └── [id].ts             # GET /api/shows/:id
│   ├── episodes/
│   │   └── [id].ts             # GET /api/episodes/:id
│   ├── auth/
│   │   ├── login.ts            # POST /api/auth/login
│   │   └── register.ts         # POST /api/auth/register
│   └── _middleware.ts          # Shared middleware (auth, error handling)
│
├── lib/                        # Shared code (frontend + backend)
│   ├── db/                     # Database layer
│   │   ├── schema.ts           # Drizzle schema definitions
│   │   ├── client.ts           # Database connection
│   │   └── migrations/         # SQL migrations (Drizzle Kit)
│   ├── domain/                 # Business logic (pure functions)
│   │   ├── shows.ts            # Show-related logic
│   │   ├── episodes.ts         # Episode-related logic
│   │   └── ratings.ts          # Rating calculations
│   ├── types/                  # Shared TypeScript types
│   │   ├── api.ts              # API request/response types
│   │   └── domain.ts           # Domain entity types
│   └── utils/                  # Shared utilities
│       ├── validation.ts       # Input validation helpers
│       └── format.ts           # Formatters, mappers
│
├── tests/                      # Tests (if not colocated)
│   ├── domain/                 # Domain logic tests
│   └── integration/            # API integration tests (optional)
│
├── .env.example                # Example environment variables
├── .env                        # Local environment variables (git-ignored)
├── drizzle.config.ts           # Drizzle ORM configuration
├── tsconfig.json               # Root TypeScript config
├── tsconfig.node.json          # Node/Vite TypeScript config
├── vite.config.ts              # Vite configuration
├── vitest.config.ts            # Vitest configuration
├── vercel.json                 # Vercel deployment config
└── package.json
```

### Naming Conventions

**Files**:
- React components: `PascalCase.tsx` (e.g., `ShowCard.tsx`)
- Utilities, helpers: `camelCase.ts` (e.g., `formatDate.ts`)
- API handlers: `camelCase.ts` or `[param].ts` for dynamic routes
- Tests: `*.test.ts` or `*.test.tsx` (colocated with code)

**Imports**:
- Use path aliases configured in `tsconfig.json`:
  - `@/components/...` → `src/components/...`
  - `@/lib/...` → `lib/...`
  - `@/api/...` → `api/...`

**Components**:
- Function components only, no class components
- Export component as default: `export default function ShowCard() { ... }`
- Props interface named `[ComponentName]Props`: `interface ShowCardProps { ... }`

**API Responses**:
- Always return JSON with consistent structure:
  ```ts
  // Success
  { data: T, error: null }

  // Error
  { data: null, error: { message: string, code?: string } }
  ```

## API Design Patterns

### RESTful Conventions

- `GET /api/shows` → List shows
- `GET /api/shows/:id` → Get show by ID
- `POST /api/shows` → Create show (if needed)
- `PUT /api/shows/:id` → Update show (if needed)
- `DELETE /api/shows/:id` → Delete show (if needed)

Use standard HTTP status codes:
- `200 OK` → Success
- `201 Created` → Resource created
- `400 Bad Request` → Validation error
- `401 Unauthorized` → Auth required
- `403 Forbidden` → Insufficient permissions
- `404 Not Found` → Resource not found
- `500 Internal Server Error` → Unhandled error

### Vercel Function Handler Pattern

Every API route exports a default handler function:

```ts
// api/shows/[id].ts
import { type VercelRequest, type VercelResponse } from '@vercel/node';
import { getShowById } from '@/lib/domain/shows';
import { db } from '@/lib/db/client';

export default async function handler(req: VercelRequest, res: VercelResponse) {
  // 1. Extract and validate input
  const { id } = req.query;
  if (typeof id !== 'string') {
    return res.status(400).json({ data: null, error: { message: 'Invalid ID' } });
  }

  // 2. Call domain logic
  try {
    const show = await getShowById(db, id);

    if (!show) {
      return res.status(404).json({ data: null, error: { message: 'Show not found' } });
    }

    // 3. Return response
    return res.status(200).json({ data: show, error: null });
  } catch (error) {
    console.error('Error fetching show:', error);
    return res.status(500).json({ data: null, error: { message: 'Internal server error' } });
  }
}
```

### Error Handling

- Use try-catch in API handlers
- Log errors with context (which endpoint, which operation)
- Never expose internal error details to client (no stack traces in production)
- Return user-friendly error messages

## Data Layer Patterns

### Drizzle ORM Usage

**Schema Definition** (`lib/db/schema.ts`):

```ts
import { pgTable, serial, text, timestamp, integer } from 'drizzle-orm/pg-core';

export const shows = pgTable('shows', {
  id: serial('id').primaryKey(),
  title: text('title').notNull(),
  description: text('description'),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
});

export const episodes = pgTable('episodes', {
  id: serial('id').primaryKey(),
  showId: integer('show_id').references(() => shows.id).notNull(),
  seasonNumber: integer('season_number').notNull(),
  episodeNumber: integer('episode_number').notNull(),
  title: text('title').notNull(),
  rating: integer('rating'), // 0-100 or similar
  createdAt: timestamp('created_at').defaultNow().notNull(),
});
```

**Database Client** (`lib/db/client.ts`):

```ts
import { drizzle } from 'drizzle-orm/node-postgres';
import { Pool } from 'pg';
import * as schema from './schema';

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
});

export const db = drizzle(pool, { schema });
```

**Query Patterns**:

```ts
// Simple query
const allShows = await db.select().from(shows);

// With where clause
const show = await db.select()
  .from(shows)
  .where(eq(shows.id, id))
  .limit(1);

// Join
const showWithEpisodes = await db.select()
  .from(shows)
  .leftJoin(episodes, eq(episodes.showId, shows.id))
  .where(eq(shows.id, id));
```

**Migrations**:
- Use Drizzle Kit: `drizzle-kit generate:pg` to create migrations
- Apply with: `drizzle-kit push:pg` or `drizzle-kit migrate`
- Store migrations in `lib/db/migrations/`

**Conventions**:
- All database queries go through Drizzle (no raw SQL unless absolutely necessary)
- Pass `db` instance as parameter to functions (dependency injection, easier testing)
- Export types from schema: `export type Show = typeof shows.$inferSelect;`

## Authentication Strategy

### High-Level Design

**Auth Storage**:
- JWT token stored in HTTP-only cookie (not accessible via JavaScript)
- Token contains user ID, email, expiration
- Token signed with secret key (stored in environment variable)

**Protected Routes**:
- API endpoints check for valid JWT in cookie
- If missing/invalid → return `401 Unauthorized`
- If valid → extract user ID, attach to request context

**Auth Endpoints**:
- `POST /api/auth/register` → Create user, return JWT
- `POST /api/auth/login` → Validate credentials, return JWT
- `POST /api/auth/logout` → Clear cookie
- `GET /api/auth/me` → Return current user info (if authenticated)

**Password Storage**:
- Hash passwords with bcrypt (or argon2)
- NEVER store plain-text passwords
- Salt per-password (handled by bcrypt automatically)

**Implementation Details** (deferred):
- Exact JWT library (e.g., `jsonwebtoken`)
- Or use a Vercel-compatible auth helper library
- Final decision in implementation phase

## Error Handling & Logging

### Error Handling

**In API Handlers**:
- Wrap all logic in try-catch
- Differentiate between expected errors (validation, not found) and unexpected errors (DB connection failure)
- Return appropriate HTTP status codes

**In Frontend**:
- Handle loading, error, and empty states explicitly
- Show user-friendly error messages (never technical details)
- Retry logic for transient failures (optional)

### Logging

**What to Log**:
- All unhandled errors (with stack trace)
- Auth events (login, logout, failed attempts)
- Performance metrics for slow queries (optional)
- Request metadata (method, path, duration)

**Logging Provider** (deferred):
- Use `console.log` / `console.error` initially (appears in Vercel logs)
- Can integrate structured logging library later (e.g., Pino, Winston)
- Can integrate external service later (e.g., Sentry, LogRocket)

**DO NOT log**:
- Passwords or tokens
- Full request bodies if they contain sensitive data
- User PII unless necessary for debugging (and then redact in prod)

## Local Development Setup

### Prerequisites

- Node.js 18+ (exact version specified in `package.json` engines)
- Docker (for local Postgres) OR managed Postgres credentials
- Vercel CLI: `npm i -g vercel`

### First-Time Setup

1. Clone repository
2. Install dependencies: `npm install`
3. Copy `.env.example` to `.env` and fill in values:
   ```
   DATABASE_URL=postgresql://user:password@localhost:5432/binge_ratings
   JWT_SECRET=your-secret-key
   ```
4. Start local Postgres (if using Docker):
   ```bash
   docker run -d \
     --name binge-ratings-db \
     -e POSTGRES_USER=user \
     -e POSTGRES_PASSWORD=password \
     -e POSTGRES_DB=binge_ratings \
     -p 5432:5432 \
     postgres:15
   ```
5. Run migrations: `npm run db:migrate`
6. Start dev environment: `npm run dev` (runs Vite + Vercel dev concurrently)

### Development Workflow

**Frontend Development**:
- `npm run dev` → Vite dev server on `http://localhost:5173`
- Hot module replacement (HMR) enabled
- Tailwind CSS auto-compiles

**Backend Development**:
- `vercel dev` → Simulates Vercel Functions locally on `http://localhost:3000`
- Frontend proxies API requests to backend (configured in `vite.config.ts`)
- Function hot-reload on file changes

**Database Changes**:
1. Edit `lib/db/schema.ts`
2. Generate migration: `npm run db:generate`
3. Apply migration: `npm run db:migrate`

**Testing**:
- Run tests: `npm test`
- Watch mode: `npm run test:watch`
- Coverage: `npm run test:coverage` (optional)

## Development Workflow

### Feature Development Process

1. **Plan**: Define feature requirements and acceptance criteria
2. **Design**: Sketch data model, API contracts, UI layout
3. **Implement**: Write code (TypeScript-first, test critical logic)
4. **Review**: Self-review for principle compliance before commit
5. **Deploy**: Push to `main` → auto-deploy to Vercel preview → merge to production

### Branching Strategy

- `main` branch is always deployable
- Feature branches: `feature/short-description` (e.g., `feature/show-ratings`)
- Commit directly to `main` for small changes (learning project, no team)
- Use branches for larger features or experiments

### Commit Standards

- Use conventional commits format: `type: description`
  - `feat:` new feature
  - `fix:` bug fix
  - `refactor:` code refactor (no behavior change)
  - `test:` add/update tests
  - `docs:` documentation
  - `chore:` tooling, config changes
- Keep commits focused and atomic
- Write clear commit messages (why, not just what)

## Governance

### Amendment Process

Constitution amendments require:
1. Written proposal with rationale in a new markdown file or GitHub issue
2. Impact analysis: what code/config needs to change?
3. Version bump following semantic versioning:
   - **MAJOR**: Backward-incompatible changes (e.g., switching from Vercel to AWS Lambda)
   - **MINOR**: New principles or technology choices (e.g., adding E2E testing)
   - **PATCH**: Clarifications, wording improvements, fixing typos
4. Update this file with new version and sync impact report
5. Update dependent templates and documentation

### Compliance

Before starting a feature:
- Review relevant constitution sections
- Ensure tech stack compliance
- Verify architecture patterns followed

During code review (self-review):
- Check for `any` types (should be rare and documented)
- Verify separation of concerns (transport vs domain vs data)
- Ensure tests exist for complex logic
- Confirm no prohibited technologies introduced

Use `/speckit.analyze` command for automated cross-artifact consistency checks.

### Versioning Policy

This constitution follows semantic versioning (MAJOR.MINOR.PATCH).
Changes are tracked in the Sync Impact Report at the top of this file.

### Open Questions (Deferred to Implementation Phase)

- **Auth Library**: Use `jsonwebtoken` directly or leverage a higher-level library?
- **Database Provider**: Neon, Supabase, Railway, or other managed Postgres?
- **Logging Provider**: Keep `console.log` or integrate Sentry/LogRocket?
- **State Management**: Built-in React hooks, or add Zustand/Jotai if complexity grows?
- **Form Handling**: Plain controlled components or use React Hook Form?
- **API Client**: Plain `fetch` or wrap in a helper (e.g., `ky` or custom wrapper)?

**Version**: 2.0.0 | **Ratified**: 2025-12-01 | **Last Amended**: 2025-12-01
